"""
Read a measurements file generated by eval_limesdr_fpga.py
and plots the PER/SNR curve, plus CFO values.
"""

import sys
from collections import defaultdict

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

if __name__ == "__main__":
    expected_payload = np.arange(100, dtype=np.uint8)
    num_bits = len(expected_payload) * 8

    ########################################################

    # PER from SNR

    ########################################################

    files = ["Measures/test.txt"]
    for i, file in enumerate(files):
        data = defaultdict(list)
        with open(file) as f:
            for line in f.read().splitlines():
                try:
                    if line.startswith("CFO"):
                        cfo, sto = line.split(",")
                        data["cfo"].append(float(cfo.split("=")[1]))
                        data["sto"].append(int(sto.split("=")[1]))
                    elif line.startswith("SNR"):
                        snr, txp = line.split(",")
                        data["snr"].append(float(snr.split("=")[1]))
                        data["txp"].append(int(txp.split("=")[1]))
                    elif line.startswith("packet"):
                        *_, payload = line.split(",", maxsplit=2)
                        payload = list(map(int, payload.split("=")[1][1:-1].split(",")))
                        ber = (
                            np.unpackbits(
                                expected_payload ^ np.array(payload, dtype=np.uint8)
                            ).sum()
                            / num_bits
                        )
                        invalid = 1 if ber > 0 else 0
                        data["ber"].append(ber)
                        data["invalid"].append(invalid)
                except Exception as e:
                    print(f"Erreur lors du traitement de la ligne : {line}\n{e}")
                    continue
    
    # Complétez les listes pour égaliser les longueurs
    max_len = max(len(v) for v in data.values())
    for key in data:
        while len(data[key]) < max_len:
            data[key].append(None)

    df = pd.DataFrame.from_dict(data)

    # Plot the CFO values for different SNR values for each TX power level(subplot) 5 for the width
    number_of_txp = len(df["txp"].unique())
    largeur = 5
    fig, axs = plt.subplots(number_of_txp//largeur, largeur, figsize=(20, 10))
    fig.suptitle("CFO values for different SNR values")
    vals = df["txp"].unique()

    count = 0
    # Plot 5 par 5
    for i in range(number_of_txp//largeur):
        for j in range(largeur):
            if count <= number_of_txp:
                df[df["txp"] == vals[count]].hist(column="cfo", ax=axs[i, j])
                axs[i, j].set_title(f"TXP: {vals[count]} dB")
                axs[i, j].set_xlabel("CFO [Hz]")
                axs[i, j].set_ylabel("Number of packets")
                count += 1
        

    plt.tight_layout()
    #plt.savefig("plots/CFO_values.pdf")
    plt.show()


    


    # For each TX power level, keep the datas with are close to the mean SNR for each TX power level
    # Compute the mean SNR for each TX power level
    txp_avg_snr = df.groupby("txp")["snr"].mean().reset_index()
    df_filtered = pd.merge(df, txp_avg_snr, on="txp", suffixes=("", "_avg"))
    df_filtered["snr_diff"] = np.abs(df_filtered["snr"] - df_filtered["snr_avg"])
    df_filtered = df_filtered[df_filtered["snr_diff"] < 0.5]  # Keep only the datas with are close to the mean SNR


    # Plot PER vs. SNR
    # Add code to plot average PER vs average SNR, for each TX power level, only for positive SNR values
    df_valid = df_filtered.dropna(subset=["snr", "invalid"])
    df_valid = df_valid[df_valid["snr"] > 0]  # Filter only positive SNR values
    df_valid["snr_int"] = df_valid["snr"].apply(lambda x: int(np.floor(x)))

    # Compute the mean SNR and the number of packets for each TX power level
    txp_data = df_valid.groupby(["txp", "snr_int"]).agg(
        snr_avg=("snr", "mean"),
        num_packets=("invalid", "size"),
        num_invalid=("invalid", "sum")
    ).reset_index()

    # Compute the number of false packets (invalid) / the number of packets for this mean SNR
    txp_data["per"] = txp_data["num_invalid"] / txp_data["num_packets"]

    # retire les 0
    txp_data = txp_data[txp_data["per"] >= 1e-6]

    # Plot the number of false packets (invalid) / the number of packets for this mean SNR
    plt.figure()
    for txp in txp_data["txp"].unique():
        txp_subset = txp_data[txp_data["txp"] == txp]
        plt.plot(txp_subset["snr_avg"], txp_subset["per"], marker='o', label=f'TXP {txp}', color='red')
    # Relie les points par des lignes
    plt.plot(txp_data["snr_avg"], txp_data["per"], linestyle='-', color='blue')
    plt.xlabel("Average SNR (dB)")
    plt.ylabel("PER (Packet Error Rate)")
    plt.ylim(1e-6, 1)  # Set the y-axis limits
    plt.yscale("log")  # Set the y-axis to logarithmic scale
    plt.title("Average PER vs. SNR for TX Power Level from -30 to -11 dB")
    #plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.savefig("plots/PER_SNR.pdf")
    plt.show()