"""
Read a measurements file generated by eval_limesdr_fpga.py
and plots the PER/SNR curve, plus CFO values.
"""

import sys
from collections import defaultdict

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

if __name__ == "__main__":
    expected_payload = np.arange(100, dtype=np.uint8)
    num_bits = len(expected_payload) * 8

    ########################################################

    # PER from SNR

    ########################################################

    files = ["Measures/measurements_1m.txt", "Measures/measurements_3m.txt", "Measures/measurements_20m.txt", "Measures/measurements_7m.txt", "Measures/measurements_12m.txt"]
    distances = [1, 3, 20, 7, 12]

    combined_data = []  # List to hold data from all files

    for idx, file in enumerate(files):
        data = defaultdict(list)  # Create a new dictionary for each file
        with open(file) as f:
            for line in f.read().splitlines():
                try:
                    if line.startswith("CFO"):
                        cfo, sto = line.split(",")
                        data["cfo"].append(float(cfo.split("=")[1]))
                        data["sto"].append(int(sto.split("=")[1]))
                    elif line.startswith("SNR"):
                        snr, txp = line.split(",")
                        data["snr"].append(float(snr.split("=")[1]))
                        data["txp"].append(int(txp.split("=")[1]))
                    elif line.startswith("packet"):
                        *_, payload = line.split(",", maxsplit=2)
                        payload = list(map(int, payload.split("=")[1][1:-1].split(",")))
                        ber = (
                            np.unpackbits(
                                expected_payload ^ np.array(payload, dtype=np.uint8)
                            ).sum()
                            / num_bits
                        )
                        invalid = 1 if ber > 0 else 0
                        data["ber"].append(ber)
                        data["invalid"].append(invalid)
                except Exception as e:
                    print(f"Error processing line: {line}\n{e}")
                    continue
            # Add distance information for this file
            data["distance"].extend([distances[idx]] * len(data["cfo"]))

        # Fill missing values to match the longest list
        max_len = max(len(v) for v in data.values())
        for key in data:
            while len(data[key]) < max_len:
                data[key].append(None)

        # Convert to DataFrame and append to the combined list
        combined_data.append(pd.DataFrame.from_dict(data))

    # Combine all DataFrames into one
    df = pd.concat(combined_data, ignore_index=True)


    """
    # Plot the CFO values for different SNR values for each TX power level(subplot) 5 for the width
    number_of_txp = len(df["txp"].unique())
    largeur = 5
    fig, axs = plt.subplots(number_of_txp//largeur, largeur, figsize=(20, 10))
    fig.suptitle("CFO values for different SNR values")
    vals = df["txp"].unique()

    count = 0
    # Plot 5 par 5
    for i in range(number_of_txp//largeur):
        for j in range(largeur):
            if count <= number_of_txp:
                df[df["txp"] == vals[count]].hist(column="cfo", ax=axs[i, j])
                axs[i, j].set_title(f"TXP: {vals[count]} dB")
                axs[i, j].set_xlabel("CFO [Hz]")
                axs[i, j].set_ylabel("Number of packets")
                count += 1
        

    plt.tight_layout()
    #plt.savefig("plots/CFO_values.pdf")
    plt.show()
    """            
    # add the code to Plot SNR vs. distance
        
    # Compute the average SNR for each distance
    
    distance_avg_snr = df.groupby("distance")["snr"].mean().reset_index()
    df = pd.merge(df, distance_avg_snr, on="distance", suffixes=("", "_avg"))
    
    # Plot the average SNR for each distance
    plt.figure()
    for distance in df["distance"].unique():
        distance_subset = df[df["distance"] == distance]
        print(distance_subset)
        plt.plot(distance, distance_subset["snr_avg"].mean(), marker='o', label=f'Distance {distance} m', color='red')
        
    plt.xlabel("Distance (m)")
    plt.ylabel("Average SNR (dB)")
    #plt.ylim(1e-4, 10)  # Set the y-axis limits
    # plt.yscale("log")  # Set the y-axis to logarithmic scale
    plt.title("Average SNR vs. Distance")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.savefig("plots/SNR_distance.pdf")
    
    distance_data = df.dropna(subset=["snr", "invalid"])
        
    # Plot the number of false packets (invalid) / the number of packets for this mean SNR
    plt.figure()
    for distance in distance_data["distance"].unique():
        distance_subset = distance_data[distance_data["distance"] == distance].copy()
        distance_subset.loc[:, "per"] = distance_subset["invalid"] / distance_subset["invalid"].size
        distance_subset = distance_subset[distance_subset["per"] >= 1e-6]
        if not distance_subset.empty:
            plt.plot([distance] * len(distance_subset), distance_subset["per"], marker='o', label=f'Distance {distance} m', color='red')
    
    # Relie les points par des lignes
    plt.xlabel("Distance (m)")
    plt.ylabel("PER (Packet Error Rate)")
    plt.ylim(1e-6, 1)  # Set the y-axis limits
    plt.yscale("log")  # Set the y-axis to logarithmic scale
    plt.title("Distance vs. SNR")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.savefig("plots/PER_distance.pdf")
    

    """
    # For each TX power level, keep the datas with are close to the mean SNR for each TX power level
    # Compute the mean SNR for each TX power level
    txp_avg_snr = df.groupby("txp")["snr"].mean().reset_index()
    df_filtered = pd.merge(df, txp_avg_snr, on="txp", suffixes=("", "_avg"))
    df_filtered["snr_diff"] = np.abs(df_filtered["snr"] - df_filtered["snr_avg"])
    df_filtered = df_filtered[df_filtered["snr_diff"] < 0.5]  # Keep only the datas with are close to the mean SNR


    # Plot PER vs. SNR
    # Add code to plot average PER vs average SNR, for each TX power level, only for positive SNR values
    df_valid = df_filtered.dropna(subset=["snr", "invalid"])
    df_valid = df_valid[df_valid["snr"] > 0]  # Filter only positive SNR values
    df_valid["snr_int"] = df_valid["snr"].apply(lambda x: int(np.floor(x)))

    # Compute the mean SNR and the number of packets for each TX power level
    txp_data = df_valid.groupby(["txp", "snr_int"]).agg(
        snr_avg=("snr", "mean"),
        num_packets=("invalid", "size"),
        num_invalid=("invalid", "sum")
    ).reset_index()

    # Compute the number of false packets (invalid) / the number of packets for this mean SNR
    txp_data["per"] = txp_data["num_invalid"] / txp_data["num_packets"]

    # retire les 0
    txp_data = txp_data[txp_data["per"] >= 1e-6]

    # save the txp_data in a file
    txp_data.to_csv("plots/txp_data.csv", index=False)

    # Plot the number of false packets (invalid) / the number of packets for this mean SNR
    plt.figure()
    for txp in txp_data["txp"].unique():
        txp_subset = txp_data[txp_data["txp"] == txp]
        plt.plot(txp_subset["snr_avg"], txp_subset["per"], marker='o', label=f'TXP {txp}', color='red')
    
    # Relie les points par des lignes
    plt.plot(txp_data["snr_avg"], txp_data["per"], linestyle='-', color='blue')
    plt.xlabel("Average SNR (dB)")
    plt.ylabel("PER (Packet Error Rate)")
    plt.ylim(1e-6, 1)  # Set the y-axis limits
    plt.yscale("log")  # Set the y-axis to logarithmic scale
    plt.title("Average PER vs. SNR for TX Power Level from -30 to -11 dB")
    #plt.legend()
    plt.grid(True)
    plt.tight_layout()
    #plt.savefig("plots/PER_SNR.pdf")
    plt.show()
    """